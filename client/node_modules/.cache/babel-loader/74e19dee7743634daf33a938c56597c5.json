{"ast":null,"code":"var _jsxFileName = \"/home/donnachin/Desktop/Git/Cloned/GroupProj/client/src/Components/ASLWordPlay/ASLWordPlayDnD.js\",\n    _s = $RefreshSig$();\n\nimport React, { useState, useRef } from 'react'; //useRef stays const during re-rendering\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function ASLWordPlayDnD({\n  data\n}) {\n  _s();\n\n  const [list, setList] = useState(data); //create state for dragging\n\n  const [dragging, setDragging] = useState(false); //keeps numbers constant\n\n  const dragItem = useRef(); //\n\n  const dragNode = useRef(); //event handler to listen to \"draggable\" event trigger onDragStart\n\n  function handleDragStart(e, params) {\n    //check to make sure this is triggered \n    console.log(\"Drag starting...\", params); //div should be:  <div draggable onDragStart={handleDragStart} key={item} className=\"dnd-item\">\n    //set dragItem to params so numbers won't change and change state to true\n\n    dragItem.current = params; //Once draggable item is completed, this event triggers the eventhandler handleDragEnd to reset\n\n    dragNode.current = e.target;\n    dragNode.current.addEventListener(\"dragend\", handleDragEnd); //set Drag time to time out like async\n\n    setTimeout(() => {\n      //sets ghost affect on card but background is visible\n      setDragging(true);\n    }, 0); //need to reset to allow next drag once drag ends\n    //so we need to create another uesrRef to reference to this node\n  } //event handler  passes event and params to allow cards to be dragged and placed in different position\n\n\n  function handleDragEnter(e, params) {\n    //if start drag, all items need to add event listener\n    //check to see if it enters into new position for card\n    //it will auto trigger when clicked but will trigger again \n    //when overlap another location = good thing, but to see which one, set grpI, itemI for onDragEnter\n    console.log('Entering drag...', params); //set init state for old list\n\n    const currentItem = dragItem.current; //check that Enter drag is not the same as Start Drag, use as ref dragNode.current = e.target;\n\n    if (e.target !== dragNode.current) {\n      //check, if true, we can do something with this, like set new position\n      console.log('TARGET NOT THE SAME'); //set new position by copying and creating new List\n\n      setList(oldList => {\n        //this allows for a deep copy of obj vs [...state] only creates shallow copy\n        let newList = JSON.parse(JSON.stringify(oldList)); //now we can modify new List to target the position we want, not init position\n        //splice allows modification, target 1 item, not removing, swap with init item ==> newList of currentItem, at index, remove item, and return list \n\n        newList[params.grpI].items.splice(params.itemI, 0, newList[currentItem.grpI].items.splice(currentItem.itemI, 1)[0]); //set current to new position on newList\n\n        dragItem.current = params; //return new modified list\n\n        return newList;\n      });\n    }\n  } //event handler triggered by drag ending, reset all methods from handDragStart\n\n\n  function handleDragEnd() {\n    //check to see if end of drag is triggered\n    console.log('Ending drag...'); //reset to initial state FIRST\n\n    setDragging(false); //remove eventListener SECOND, then reset everything else\n\n    dragNode.current.removeEventListener(\"dragend\", handleDragEnd); //set dragItem to null to reset\n\n    dragItem.current = null; //Once draggable item is completed, this event triggers the eventhandler handleDragEnd to reset\n\n    dragNode.current = null;\n  } //getStyles function, target using params as arg\n\n\n  function getStyles(params) {\n    //set conditions for selected card to be dragged\n    const currentItem = dragItem.current;\n\n    if (currentItem.grpI === params.grpI && currentItem.itemI === params.itemI) {\n      return 'current dnd-item';\n    } //indicator to style card differently in item\n    //this applies to all cards when dragged, we want only selected\n    //so we pass {grpI, itemI} in className for getStyles to target specific card\n\n\n    return 'dnd-item';\n  }\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"drag-n-drop\",\n    children: list.map((grp, grpI) => /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"dnd-group\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"group-title\" //if dragging and item has value of 0, allows init drag item to return and set to init position\n        ,\n        onDragEnter: dragging && !grp.items.length ? e => handleDragEnter(e, {\n          grpI,\n          itemI: 0\n        }) : null,\n        children: grp.title\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 107,\n        columnNumber: 18\n      }, this), grp.items.map((item, itemI) => /*#__PURE__*/_jsxDEV(\"div\", {\n        // \"draggable\" allows you to ghost drag item\n        draggable: true // onDragStart creates evenet that triggers event handler to set drag onto the grouped item selected, like coordinates\n        ,\n        onDragStart: e => handleDragStart(e, {\n          grpI,\n          itemI\n        }) //If dragging is true, allow current card to trigger handleDragEnter, else nothing\n        ,\n        onDragEnter: e => dragging ? handleDragEnter(e, {\n          grpI,\n          itemI\n        }) : null,\n        // create ternary condition rendering, if dragging is true\n        //If we are dragging, only item inside getStyles() affected, else stays as init state on as \"dnd-item\"\n        className: dragging ? getStyles({\n          grpI,\n          itemI\n        }) : \"dnd-item\",\n        children: item\n      }, item, false, {\n        fileName: _jsxFileName,\n        lineNumber: 118,\n        columnNumber: 21\n      }, this))]\n    }, grp.title, true, {\n      fileName: _jsxFileName,\n      lineNumber: 106,\n      columnNumber: 15\n    }, this))\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 102,\n    columnNumber: 7\n  }, this);\n}\n\n_s(ASLWordPlayDnD, \"4hFDioJyiC0eLqqFfNeS+/qcApo=\");\n\n_c = ASLWordPlayDnD;\n\nvar _c;\n\n$RefreshReg$(_c, \"ASLWordPlayDnD\");","map":{"version":3,"sources":["/home/donnachin/Desktop/Git/Cloned/GroupProj/client/src/Components/ASLWordPlay/ASLWordPlayDnD.js"],"names":["React","useState","useRef","ASLWordPlayDnD","data","list","setList","dragging","setDragging","dragItem","dragNode","handleDragStart","e","params","console","log","current","target","addEventListener","handleDragEnd","setTimeout","handleDragEnter","currentItem","oldList","newList","JSON","parse","stringify","grpI","items","splice","itemI","removeEventListener","getStyles","map","grp","length","title","item"],"mappings":"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","sourcesContent":["import React, { useState, useRef } from 'react'\n//useRef stays const during re-rendering\n\nexport default function ASLWordPlayDnD ({ data }) {\n\n    const [list, setList] = useState(data);\n\n    //create state for dragging\n    const [dragging, setDragging] = useState(false);\n\n    //keeps numbers constant\n    const dragItem = useRef();\n\n    //\n    const dragNode = useRef();\n\n    //event handler to listen to \"draggable\" event trigger onDragStart\n    function handleDragStart (e, params) {\n        //check to make sure this is triggered \n        console.log(\"Drag starting...\", params)\n        //div should be:  <div draggable onDragStart={handleDragStart} key={item} className=\"dnd-item\">\n        \n        //set dragItem to params so numbers won't change and change state to true\n        dragItem.current = params;\n        //Once draggable item is completed, this event triggers the eventhandler handleDragEnd to reset\n        dragNode.current = e.target;\n        dragNode.current.addEventListener(\"dragend\", handleDragEnd)\n         //set Drag time to time out like async\n         setTimeout(() => {\n             //sets ghost affect on card but background is visible\n            setDragging(true);\n         }, 0)\n        \n          //need to reset to allow next drag once drag ends\n        //so we need to create another uesrRef to reference to this node\n\n    }\n\n    //event handler  passes event and params to allow cards to be dragged and placed in different position\n    function handleDragEnter (e, params) {\n        //if start drag, all items need to add event listener\n        //check to see if it enters into new position for card\n        //it will auto trigger when clicked but will trigger again \n        //when overlap another location = good thing, but to see which one, set grpI, itemI for onDragEnter\n        console.log('Entering drag...', params)\n\n        //set init state for old list\n        const currentItem = dragItem.current;\n        \n        //check that Enter drag is not the same as Start Drag, use as ref dragNode.current = e.target;\n        if (e.target !== dragNode.current) {\n            //check, if true, we can do something with this, like set new position\n            console.log('TARGET NOT THE SAME')\n            //set new position by copying and creating new List\n            setList(oldList => {\n                //this allows for a deep copy of obj vs [...state] only creates shallow copy\n                let newList = JSON.parse(JSON.stringify(oldList));\n                //now we can modify new List to target the position we want, not init position\n                //splice allows modification, target 1 item, not removing, swap with init item ==> newList of currentItem, at index, remove item, and return list \n                newList[params.grpI].items.splice(params.itemI, 0, newList[currentItem.grpI].items.splice(currentItem.itemI, 1)[0])\n                \n                //set current to new position on newList\n                dragItem.current = params\n\n                //return new modified list\n                return newList\n            })\n        }\n    }\n\n    //event handler triggered by drag ending, reset all methods from handDragStart\n    function handleDragEnd(){\n        //check to see if end of drag is triggered\n        console.log('Ending drag...')\n        \n         //reset to initial state FIRST\n         setDragging(false);\n         //remove eventListener SECOND, then reset everything else\n         dragNode.current.removeEventListener(\"dragend\", handleDragEnd);\n          //set dragItem to null to reset\n          dragItem.current = null;\n          //Once draggable item is completed, this event triggers the eventhandler handleDragEnd to reset\n          dragNode.current = null;\n    }\n\n    //getStyles function, target using params as arg\n    function getStyles(params) {\n        //set conditions for selected card to be dragged\n        const currentItem = dragItem.current;\n        if (currentItem.grpI === params.grpI && currentItem.itemI === params.itemI) {\n            return 'current dnd-item'\n        }\n\n        //indicator to style card differently in item\n        //this applies to all cards when dragged, we want only selected\n        //so we pass {grpI, itemI} in className for getStyles to target specific card\n        return 'dnd-item'\n    }\n\n    return (\n\n      <div className=\"drag-n-drop\">\n\n          {\n            list.map((grp, grpI) => (\n              <div key={grp.title} className=\"dnd-group\">\n                 <div \n                    className=\"group-title\"\n                    //if dragging and item has value of 0, allows init drag item to return and set to init position\n                    onDragEnter={ dragging && !grp.items.length? (e) => handleDragEnter(e, {grpI, itemI: 0}) :null }\n                >\n                    {grp.title}\n                </div>\n\n                { \n                  grp.items.map((item, itemI) => (\n\n                    <div \n                    // \"draggable\" allows you to ghost drag item\n                        draggable \n                        // onDragStart creates evenet that triggers event handler to set drag onto the grouped item selected, like coordinates\n                        onDragStart={(e) => (handleDragStart(e, {grpI, itemI}))} \n                        //If dragging is true, allow current card to trigger handleDragEnter, else nothing\n                        onDragEnter={ (e) => dragging ? handleDragEnter(e, {grpI, itemI}) : null }\n                        key={item} \n                        // create ternary condition rendering, if dragging is true\n                        //If we are dragging, only item inside getStyles() affected, else stays as init state on as \"dnd-item\"\n                        className={ dragging ? getStyles({grpI, itemI}) :  \"dnd-item\" }\n                    >\n                        {item}\n                    </div>\n                  ))\n                }\n\n              </div>\n            ))\n          }\n        </div>\n\n    )\n}"]},"metadata":{},"sourceType":"module"}